

并发控制

在单CPU系统中，事务的并行执行实际上是这些并行事务的并行操作轮流交叉运行。这种并行执行方式称为交叉并发方式。虽然单CPU系统中的并行事务并没有真正的并行运行，但是减少了CPU空闲时间，提高了系统的效率。在多CPU系统中，每个CPU可以运行一个事务，多个CPU可以同时运行多个事务，实现多个事务真正的并行运行。这种并行执行方式称为同时并发方式。

当多个用户并发的存取数据库时就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会存取和存储不正确的数据，破坏数据库的一致性。所以数据库管理系统必须提供并发控制机制。并发控制机制是衡量一个DBMS性能的重要标志之一。

事务是并发控制的基本单位，事务ACID特性可能遭到破坏的原因之一是多个事务对数据库的并发操作造成的。为了保证事务的隔离性更一般，为了保证数据库的一致性，DBMS需要对并发操作进行正确调度。这些就是DBMS中并发控制机制的责任。

并发操作带来的数据不一致性包括三类：丢失修改、不可重复读和读脏数据。

1，丢失修改
两个事务T1和T2读入同一数据并修改，T2提交的结果破坏了T1提交的结果，导致T1的修改被丢失。
2，不可重复读
事务T1读取数据后，事务T2执行更新(增删改)操作，使T1无法再现前一次读取的结果。
3，读脏数据
读脏数据是指事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤销，这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致，则T2读到的数据就是脏数据，即不正确的数据。


并发控制的主要技术是锁机制(Locking)

锁机制是实现并发控制的一个非常重要的技术。所谓封锁就是事务T在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其他的事务不能更新此数据对象。
确切的控制由加锁的类型决定。基本的加锁类型有两种：排他锁(Exclusive Lock)和共享锁(Share Lock)。
排他锁又称为写锁。若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。
共享锁又称为读锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。


加锁协议


在运用X锁和S锁这两种基本加锁对数据对象加锁时，还需要约定一些规则，例如何时申请X锁或S锁、持续时间、何时释放等。称这些规则为加锁协议。对加锁方式规定不同的规则，就形成了各种不同的加锁协议。对并发操作的不正确调度可能会带来丢失修改、不可重复读和读脏数据等不一致性问题，三级加锁协议分别在不同程度上解决了这一问题。

一级加锁协议
事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束COMMIT和非正常结束ROLLBACK。
一级加锁协议可防止丢失修改，并保证事务T是可恢复的。例：
事务T1在读数据对象A进行修改之前先对A加X锁，当事务T2再请求对A加X锁时被拒绝，T2只能等待T1释放A上的锁后才能获得对A的X锁，这时它读到的A已经是T1更新过的值，再按此新的A值进行运算。这样就避免了丢失T1的更新。
在一级加锁协议中，如果仅仅是读数据(指T2)不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读脏数据。

二级加锁协议
一级加锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。
二级加锁协议除防止了丢失修改，还可进一步防止读脏数据。例：
事务T1在对数据对象C进行修改之前，先对C加X锁，修改其值后写回磁盘。这时T2请求在C上加S锁，因T1已经在C上加了X锁，T2只能等待。T1因某种原因被撤销，C恢复为原值，T1释放C上的X锁后T2获得C上的S锁，读C为原值。这样就避免了T2读脏数据。
在二级加锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。

三级加锁协议
一级加锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。
三级加锁协议除防止了丢失修改和不读脏数据外，还进一步防止了不可重复读。例：
事务T1在读B之前，先对B加S锁，这样其他事务只能再对B加S锁，而不能加X锁，即其他事务只能读B，而不能修改它们。所以当T2为修改B而申请对B的X锁时被拒绝只能等待T1释放B上的锁。T1为验算再读B，这时读出的B仍是原值。

上述三级协议的主要区别在于什么操作需要申请封锁以及何时释放锁。


活锁和死锁

加锁的方法可能引起活锁和死锁。

活锁

如果事务T1加锁了数据R，事务T2又请求加锁R，于是T2等待。T3也请求加锁R，当T1释放了R上的锁之后系统首先批准了T3的请求，T2仍然等待。然后T4又请求加锁R，当T3释放了R上的锁之后系统又批准了T4的请求……T2有可能永远等待，这就是活锁的情形。
避免活锁的简单方法是采用先来先服务的策略。当多个事务请求加锁同一数据对象时，加锁子系统按请求加锁的先后次序对事务排队，数据对象上的锁一旦释放就批准申请队列中第一个事务获得锁。

死锁

如果事务T1加锁了数据R1，T2加锁了数据R2，然后T1又请求加锁R2，因T2已加锁了R2，于是T1等待T2释放R2上的锁。接着T2又申请加锁R1，因T1已加锁了R1，T2也只能等待T1释放R1上的锁。这样就出现了T1在等待T2，而T2又在等待T1的局面，T1和T2两个事务永远不能结束，形成死锁。

DBMS在解决死锁的问题上普遍采用的是诊断并解除死锁的方法。

超时法

如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。超时法实现简单，但其不足也很明显。一是有可能误判死锁，事务因为其他原因使等待时间超过时限，系统会误认为发生了死锁。二是时限若设置得太长，死锁发生后不能及时发现。

等待图法

事务等待图是一个有向图 G=(T,U)。T为结点的集合，每个结点表示正运行的事务；U为边的集合，每条边表示事务等待的情况。若T1等待T2，则T1、T2之间划一条有向边，从T1指向T2。事务等待图动态的反映了所有事务的等待情况。并发控制子系统周期性的(比如每隔1分钟)检测事务等待图，如果发现图中存在回路，则表示系统中出现了死锁。
DBMS的并发控制子系统一旦检测到系统中存在死锁，就要设法解除。通常采用的方法是选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有的锁，使其他事务得以继续运行下去。当然，对撤销的事务所执行的数据修改操作必须加以恢复。


并发调度的可串行性

如果一个事务运行过程中没有其他事务同时运行，也就是说它没有受到其他事务的干扰，那么就可以认为该事务的运行结果是正常的或者预想的。因此将所有事务串行起来的调度策略一定是正确的调度策略。虽然以不同的顺序串行执行事务可能会产生不同的结果，但由于不会将数据库置于不一致状态，所以都是正确的。

定义：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行它们时的结果相同，称这种调度策略为可串行化的调度。

可串行性是并发事务正确性的准则。按这个准则规定，一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。

为保证并发操作的正确性，DBMS的并发控制机制必须提供一定的手段来保证调度是可串行化的。

从理论上讲，在某一事务执行时禁止其他事务执行的调度策略一定是可串行化的调度，这也是最简单的调度策略，但这种方法实际上是不可取的，这使用户不能充分共享数据库资源。目前DBMS普遍采用加锁方法实现并发操作调度的可串行性，从而保证调度的正确性。

两段锁协议就是保证并发调度可串行性的加锁协议。所谓两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁：
1，在对任何数据进行读写操作之前，首先要申请并获得对该数据的锁。
2，在释放一个锁之后，事务不再申请和获得任何其他锁。
所谓两段锁的含义是：事务分为两个阶段，第一阶段是获得锁，也称为扩展阶段。在这阶段，事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁。第二阶段是释放锁，也称为收缩阶段。在这阶段，事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁。事务遵循两段锁协议是可串行化调度的充分条件，而不是必要条件。两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵循两段锁协议的事务可能发生死锁。
