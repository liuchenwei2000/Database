

并发控制主要有两种方式：乐观锁和悲观锁。


悲观锁（Pessimistic Locking，假定会发生冲突，屏蔽一切可能违反数据库完整性的操作。）

它可以阻止一个事务以影响其他事务的方式来修改数据。如果一个事务执行的操作在某行数据上应用了锁，那只有当这个事务把锁释放，其他事务才能执行与该锁冲突的操作。

实现机理：
依靠数据库的锁机制实现加锁，如 SELECT ... FOR UPDATE。

优缺点：
悲观锁才去的是“先加锁再访问”的保守策略，为数据处理的安全性提供了保证。但在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加死锁的机会。另外，在只读型事务处理中由于不会产生冲突，也没有必要使用锁，这样做只会增加系统负载。此外，它会降低并发性，一个事务锁定某行数据，其他事务只能等到该事务处理完才可以处理那行数据。

应用场景：
主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。


乐观锁（Optimistic Locking，假定不会发生冲突，只在提交时检查是否违反数据完整性。）

并发的各事务能够在不产生锁（数据库锁）的情况下自由读取并处理数据。在提交数据更新之前，每个事务都会检查在该事务读取数据后，有没有其他事务又修改了该数据，有的话，则该事务会回滚。

实现机理：
1，读取：事务将数据读入，该数据有一个列记录版本号或时间戳。
2，校验：事务执行完毕准备提交，此时会校验版本号或时间戳，以判断数据是否在读取后又被别的事务修改。
3，写入：若通过校验，则更新的数据写入数据库，否则事务回滚。

优缺点：
乐观锁的实现不依赖数据库锁机制，完全是基于系统的数据存储逻辑，因此不会产生任何锁和死锁，但也无法解决脏读的问题。另外，若外系统直接修改数据，则会绕过这道校验。可将乐观锁机制在数据库存储过程中实现，只对外开放基于存储过程的数据更新，而不允许直接操作表。

应用场景：
多数用于数据争用不大冲突较少的环境，偶尔的事务回滚的成本也低于读取数据时锁定数据的成本，因此可获得更高的吞吐量。